# sleep 、wait、yield与join的区别，wait 的线程如何唤醒它？

在Android开发（本质上是Java多线程机制）中，`Thread.sleep()`、`wait()`、`yield()`和`join()`都是用于线程控制的方法，但它们的作用和使用场景有显著区别。以下是详细说明：


### 一、核心区别对比
| 特性                | `Thread.sleep(long)`       | `Object.wait()`            | `Thread.yield()`           | `Thread.join()`            |
|---------------------|---------------------------|---------------------------|---------------------------|---------------------------|
| 所属类              | `Thread`（静态方法）       | `Object`（实例方法）       | `Thread`（静态方法）       | `Thread`（实例方法）       |
| 是否释放锁          | 不释放（持有锁时仍独占）   | 释放（必须在同步块中调用） | 不释放（仍持有锁）         | 释放（底层通过`wait()`实现）|
| 作用                | 让当前线程暂停指定时间     | 让当前线程进入等待状态     | 让当前线程让出CPU执行权    | 让当前线程等待目标线程结束 |
| 唤醒方式            | 时间到后自动唤醒           | 需其他线程调用`notify()`/`notifyAll()`或超时 | 重新参与CPU调度（可能立即被选中） | 目标线程执行完毕后自动唤醒 |
| 使用场景            | 简单延时（如模拟网络等待） | 线程间通信（如生产者-消费者模型） | 调试或优先级调整（实际用得少） | 等待子线程完成后再执行（如主线程等子线程数据） |


### 二、详细说明
#### 1. `Thread.sleep(long millis)`
- **作用**：让当前正在执行的线程暂停指定的毫秒数（进入**阻塞状态**），时间结束后自动恢复运行。
- **关键特性**：
  - 不会释放当前线程持有的锁（如`synchronized`锁），因此如果在同步块中调用`sleep`，其他线程仍无法进入该同步块。
  - 必须处理`InterruptedException`（线程休眠时被中断会抛出此异常）。
- **示例**：
  ```java
  new Thread(() -> {
      synchronized (lock) {
          try {
              Thread.sleep(1000); // 休眠1秒，仍持有lock锁
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  }).start();
  ```


#### 2. `Object.wait()`
- **作用**：让当前线程释放持有的对象锁，进入该对象的**等待队列**，直到被唤醒或超时。
- **关键特性**：
  - 必须在`synchronized`同步块/方法中调用（否则会抛出`IllegalMonitorStateException`），因为调用前必须先获取对象锁。
  - 会主动释放锁，让其他线程有机会获取该对象的锁。
  - 有重载方法`wait(long timeout)`（超时后自动唤醒）和`wait(long timeout, int nanos)`。
- **示例**：
  ```java
  synchronized (lock) {
      try {
          lock.wait(); // 释放lock锁，进入等待状态
      } catch (InterruptedException e) {
          e.printStackTrace();
      }
  }
  ```


#### 3. `Thread.yield()`
- **作用**：让当前线程主动让出CPU执行权（进入**就绪状态**），重新参与CPU调度（可能立即再次被选中执行）。
- **关键特性**：
  - 仅对**优先级相同或更高**的线程有“礼让”意义，底层依赖操作系统调度机制（不一定真的让权）。
  - 不释放锁，也不会阻塞线程，只是短暂“休息”。
- **示例**：
  ```java
  new Thread(() -> {
      for (int i = 0; i < 10; i++) {
          System.out.println("Thread A: " + i);
          Thread.yield(); // 让出CPU，让其他线程有机会执行
      }
  }).start();
  ```


#### 4. `Thread.join()`
- **作用**：让当前线程等待目标线程执行完毕后再继续运行（当前线程进入**阻塞状态**）。
- **关键特性**：
  - 例如：主线程中调用`thread.join()`，主线程会阻塞，直到`thread`执行完才继续。
  - 底层通过`wait()`实现，因此会释放当前线程持有的锁。
  - 有重载方法`join(long millis)`（超时后不再等待）。
- **示例**：
  ```java
  Thread subThread = new Thread(() -> {
      // 子线程任务
  });
  subThread.start();
  try {
      subThread.join(); // 主线程等待subThread执行完毕
  } catch (InterruptedException e) {
      e.printStackTrace();
  }
  ```


### 三、`wait()`的线程如何唤醒？
调用`wait()`的线程会进入对象的等待队列，需通过以下方式唤醒：

1. **`notify()`**：唤醒该对象等待队列中**随机一个**线程（具体唤醒哪个由JVM决定）。
2. **`notifyAll()`**：唤醒该对象等待队列中**所有**线程（所有线程重新竞争锁，获得锁的线程继续执行）。
3. **超时自动唤醒**：如果调用的是`wait(long timeout)`，当等待时间超过`timeout`毫秒后，线程会自动唤醒。


**注意**：`notify()`/`notifyAll()`必须在与`wait()`相同的`synchronized`同步块/方法中调用（即必须持有同一个对象的锁），否则会抛出`IllegalMonitorStateException`。

**示例（唤醒逻辑）**：
```java
// 等待线程
synchronized (lock) {
    while (conditionNotMet) { // 用while防止虚假唤醒
        lock.wait(); // 释放锁，等待被唤醒
    }
    // 被唤醒后执行逻辑
}

// 唤醒线程
synchronized (lock) {
    conditionNotMet = false; // 改变条件
    lock.notify(); // 或 notifyAll() 唤醒等待线程
}
```

（注：使用`while`判断条件而非`if`，是为了防止“虚假唤醒”——线程可能在未被`notify`的情况下被唤醒，此时需重新检查条件。）


### 总结
- `sleep`：纯延时，不释放锁，用于简单暂停。
- `wait`：释放锁，用于线程间通信，需`notify`唤醒。
- `yield`：礼让CPU，不释放锁，作用有限。
- `join`：等待其他线程完成，用于线程同步。

理解这些方法的核心区别（尤其是锁的处理和唤醒机制），是正确处理多线程协作的关键。