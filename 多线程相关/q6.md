# 线程池有几种实现方式，构造线程池的参数有哪些，它们有什么作用？

在Android开发中，线程池的实现基于Java的`Executor`框架，核心是`ThreadPoolExecutor`类。以下是关于线程池的实现方式、构造参数及作用的详细说明：


### 一、线程池的常见实现方式
Android中常用的线程池通过`Executors`工具类创建，本质上都是`ThreadPoolExecutor`的封装，主要有以下4种：

1. **FixedThreadPool（固定线程数线程池）**  
   - 特点：线程数量固定（核心线程数=最大线程数），空闲时核心线程不会被回收，任务队列无界。  
   - 适用场景：处理CPU密集型任务（如计算），避免频繁创建线程的开销。  
   - 实现：`Executors.newFixedThreadPool(nThreads)`  


2. **CachedThreadPool（可缓存线程池）**  
   - 特点：核心线程数为0，最大线程数无限制（理论上`Integer.MAX_VALUE`），空闲线程存活时间60秒，任务队列使用同步队列（无缓冲）。  
   - 适用场景：处理大量短期异步任务（如网络请求），线程会根据任务自动创建和回收。  
   - 实现：`Executors.newCachedThreadPool()`  


3. **ScheduledThreadPool（定时任务线程池）**  
   - 特点：核心线程数固定，最大线程数无限制，支持定时或周期性执行任务。  
   - 适用场景：需要延迟执行（如3秒后执行）或周期性执行（如每隔1分钟执行）的任务。  
   - 实现：`Executors.newScheduledThreadPool(corePoolSize)`  


4. **SingleThreadExecutor（单线程线程池）**  
   - 特点：只有1个核心线程，所有任务按顺序执行，任务队列无界。  
   - 适用场景：需要串行执行的任务（如UI更新前的预处理），保证任务执行顺序。  
   - 实现：`Executors.newSingleThreadExecutor()`  


### 二、ThreadPoolExecutor的核心构造参数
上述线程池本质上都是通过`ThreadPoolExecutor`的构造方法实现的，其核心构造参数如下（共7个）：

```java
public ThreadPoolExecutor(
    int corePoolSize,          // 核心线程数
    int maximumPoolSize,       // 最大线程数
    long keepAliveTime,        // 非核心线程空闲存活时间
    TimeUnit unit,             // 存活时间的单位（如秒、毫秒）
    BlockingQueue<Runnable> workQueue,  // 任务队列（存放等待执行的任务）
    ThreadFactory threadFactory,        // 线程工厂（用于创建线程）
    RejectedExecutionHandler handler    // 拒绝策略（任务无法处理时的处理方式）
)
```


### 三、各参数的作用
1. **corePoolSize（核心线程数）**  
   - 线程池长期维持的线程数量（即使线程空闲）。  
   - 任务提交时，若当前线程数小于核心线程数，会直接创建新线程执行任务；若达到核心线程数，任务会被放入队列等待。  


2. **maximumPoolSize（最大线程数）**  
   - 线程池允许创建的最大线程数（核心线程+非核心线程）。  
   - 当任务队列满了，且当前线程数小于最大线程数时，会创建非核心线程执行任务；若达到最大线程数，会触发拒绝策略。  


3. **keepAliveTime + unit（空闲存活时间及单位）**  
   - 仅对“非核心线程”有效：当非核心线程空闲时间超过该值，会被回收。  
   - 若通过`allowCoreThreadTimeOut(true)`设置，核心线程也会遵守该规则。  


4. **workQueue（任务队列）**  
   - 用于存放“已提交但未执行”的任务，必须是`BlockingQueue`类型（支持阻塞操作）。  
   - 常见队列类型：  
     - `LinkedBlockingQueue`：无界队列（默认容量`Integer.MAX_VALUE`），如FixedThreadPool使用。  
     - `SynchronousQueue`：同步队列（不存储任务，直接传递给线程），如CachedThreadPool使用。  
     - `ArrayBlockingQueue`：有界队列（需指定容量），更适合控制资源占用。  


5. **threadFactory（线程工厂）**  
   - 用于创建线程的工厂，可自定义线程名称、优先级、是否为守护线程等。  
   - 示例：通过`ThreadFactory`设置线程名称为“my-thread-pool-%d”，便于调试。  


6. **handler（拒绝策略）**  
   - 当任务无法被处理时（如线程数达最大值且队列满）的处理方式。  
   - 内置拒绝策略：  
     - `AbortPolicy`（默认）：直接抛出`RejectedExecutionException`。  
     - `CallerRunsPolicy`：让提交任务的线程（如主线程）自己执行任务，减缓提交速度。  
     - `DiscardPolicy`：直接丢弃任务，不做任何处理。  
     - `DiscardOldestPolicy`：丢弃队列中最旧的任务，尝试提交新任务。  


### 四、开发注意事项
- 不建议直接使用`Executors`创建线程池（如CachedThreadPool可能创建大量线程导致OOM），推荐手动创建`ThreadPoolExecutor`并指定有界队列和合理的最大线程数。  
- 线程池的参数需根据业务场景调整（如CPU密集型任务核心线程数可设为CPU核心数，IO密集型可设为CPU核心数的2-4倍）。  
- 避免线程池持有Activity上下文，防止内存泄漏。