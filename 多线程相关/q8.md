# 死锁的几种场景和解决方案

在Android开发中，死锁是多线程编程中常见的问题，通常由多个线程互相持有对方所需的资源（锁）且不释放导致。以下是几种典型场景及对应的解决方案：


### **场景1：多线程争夺锁的顺序不一致**
**问题描述**：两个线程分别持有对方需要的锁，并互相等待对方释放锁，导致无限阻塞。  
**示例**：  
假设存在两个锁 `lock1` 和 `lock2`，线程A先获取 `lock1` 再尝试获取 `lock2`，而线程B先获取 `lock2` 再尝试获取 `lock1`：
```java
// 定义两个锁对象
private final Object lock1 = new Object();
private final Object lock2 = new Object();

// 线程A：先拿lock1，再等lock2
new Thread(() -> {
    synchronized (lock1) {
        try {
            Thread.sleep(100); // 模拟耗时操作
        } catch (InterruptedException e) { /* 忽略 */ }
        // 此时线程A持有lock1，等待lock2
        synchronized (lock2) {
            Log.d("Deadlock", "线程A获取到两个锁");
        }
    }
}).start();

// 线程B：先拿lock2，再等lock1
new Thread(() -> {
    synchronized (lock2) {
        try {
            Thread.sleep(100); // 模拟耗时操作
        } catch (InterruptedException e) { /* 忽略 */ }
        // 此时线程B持有lock2，等待lock1
        synchronized (lock1) {
            Log.d("Deadlock", "线程B获取到两个锁");
        }
    }
}).start();
```
**结果**：线程A持有 `lock1` 等待 `lock2`，线程B持有 `lock2` 等待 `lock1`，双方无限阻塞，形成死锁。


### **场景2：主线程与子线程的互相等待**
**问题描述**：主线程（UI线程）等待子线程执行结果，而子线程需要主线程的资源（如通过 `Handler` 发送消息到主线程处理），导致互相等待。  
**示例**：  
主线程调用 `join()` 等待子线程结束，但子线程需要主线程处理 `Handler` 消息才能完成：
```java
private Handler mHandler = new Handler(Looper.getMainLooper()) {
    @Override
    public void handleMessage(Message msg) {
        Log.d("Deadlock", "主线程处理消息");
        // 子线程需要此消息处理完成才能继续
        synchronized (lock) {
            lock.notify(); // 唤醒子线程
        }
    }
};

private final Object lock = new Object();

// 主线程代码（如Activity的onCreate）
new Thread(() -> {
    synchronized (lock) {
        // 子线程发送消息到主线程
        mHandler.sendEmptyMessage(0);
        try {
            // 子线程等待主线程处理消息
            lock.wait();
        } catch (InterruptedException e) { /* 忽略 */ }
    }
    Log.d("Deadlock", "子线程完成");
}).start();

// 主线程等待子线程结束（导致死锁）
try {
    thread.join(); // 主线程阻塞等待子线程
} catch (InterruptedException e) { /* 忽略 */ }
```
**结果**：主线程因 `join()` 阻塞，无法处理 `Handler` 消息；子线程因 `wait()` 等待主线程的 `notify()`，双方互相等待，形成死锁。


### **场景3：锁嵌套与资源竞争**
**问题描述**：在同步方法/代码块中嵌套调用其他同步方法，导致锁的获取顺序混乱。  
**示例**：  
两个同步方法 `methodA` 和 `methodB` 互相调用，线程1调用 `methodA` 时持有 `lockA`，并尝试调用 `methodB` 获取 `lockB`；线程2调用 `methodB` 时持有 `lockB`，并尝试调用 `methodA` 获取 `lockA`：
```java
private final Object lockA = new Object();
private final Object lockB = new Object();

// 方法A：持有lockA，调用方法B（需要lockB）
private void methodA() {
    synchronized (lockA) {
        Log.d("Deadlock", "methodA持有lockA");
        methodB(); // 尝试获取lockB
    }
}

// 方法B：持有lockB，调用方法A（需要lockA）
private void methodB() {
    synchronized (lockB) {
        Log.d("Deadlock", "methodB持有lockB");
        methodA(); // 尝试获取lockA
    }
}

// 线程1调用methodA
new Thread(this::methodA).start();
// 线程2调用methodB
new Thread(this::methodB).start();
```
**结果**：线程1持有 `lockA` 等待 `lockB`，线程2持有 `lockB` 等待 `lockA`，形成死锁。


### **解决方案**
针对上述场景，核心思路是**避免线程间互相等待不可释放的资源**，具体方案如下：

#### 1. 统一锁的获取顺序
多线程获取多个锁时，严格按照固定顺序获取，避免交叉等待。  
**改进场景1**：  
```java
// 线程A和线程B都先获取lock1，再获取lock2（顺序统一）
// 线程A
synchronized (lock1) {
    synchronized (lock2) { /* 操作 */ }
}
// 线程B
synchronized (lock1) {
    synchronized (lock2) { /* 操作 */ }
}
```

#### 2. 避免主线程阻塞等待子线程
主线程（UI线程）不能被阻塞（否则会ANR），应使用回调而非 `join()` 或 `wait()` 等待子线程。  
**改进场景2**：  
```java
// 子线程执行完成后通过Handler通知主线程（而非主线程等待子线程）
new Thread(() -> {
    // 子线程处理逻辑
    mHandler.post(() -> {
        // 主线程处理结果（回调）
        Log.d("Deadlock", "子线程完成，主线程处理");
    });
}).start();
```

#### 3. 减少锁的嵌套与范围
- 避免同步方法/代码块的嵌套调用。  
- 缩小锁的作用范围（仅在必要时加锁）。  
**改进场景3**：  
```java
// 移除方法间的嵌套调用，或合并为单锁（如果逻辑允许）
private final Object singleLock = new Object();

private void methodA() {
    synchronized (singleLock) { /* 操作 */ }
}

private void methodB() {
    synchronized (singleLock) { /* 操作 */ }
}
```

#### 4. 使用显式锁与超时机制
用 `ReentrantLock` 替代 `synchronized`，通过 `tryLock(timeout)` 避免无限等待：
```java
private final ReentrantLock lock1 = new ReentrantLock();
private final ReentrantLock lock2 = new ReentrantLock();

// 尝试获取锁，超时则放弃
try {
    if (lock1.tryLock(1, TimeUnit.SECONDS)) {
        if (lock2.tryLock(1, TimeUnit.SECONDS)) {
            // 成功获取两个锁，执行操作
        } else {
            lock1.unlock(); // 释放已获取的锁
        }
    }
} catch (InterruptedException e) { /* 处理中断 */ }
```

#### 5. 避免不必要的锁
优先使用线程安全的数据结构（如 `ConcurrentHashMap`）或无锁设计（如 `AtomicInteger`），减少手动加锁需求。


### 总结
Android中的死锁本质是**资源竞争与等待顺序混乱**，解决核心是：  
- 统一锁的获取顺序；  
- 避免主线程阻塞；  
- 减少锁的嵌套和范围；  
- 利用显式锁的超时机制。  

通过合理的线程通信（如 `Handler`、`LiveData`）和并发工具（如 `ReentrantLock`、`Executor`），可有效降低死锁风险。