# AQS的原理及用途

### 一、AQS 是什么？

AQS，即 **抽象队列同步器**，是 Java 并发包 `java.util.concurrent.locks` 的核心基础组件。它提供了一个**框架**，用于实现依赖于先进先出（FIFO）等待队列的阻塞锁和相关同步器（如信号量、事件等）。

简单来说，AQS 解决了在实现同步器时涉及的大量底层细节问题，例如：
*   **线程的阻塞与唤醒**
*   **等待队列的管理**
*   **同步状态（state）的原子性管理**

基于 AQS，我们可以非常简单地构建出各种广泛使用的同步器，如 `ReentrantLock`, `Semaphore`, `CountDownLatch`, `ReentrantReadWriteLock` 等。

---

### 二、核心原理

AQS 的核心思想可以概括为三点：**一个状态（state）、一个队列（CLH变体）、两种模式（独占/共享）**。

#### 1. 同步状态（State）
AQS 内部维护了一个用 `volatile` 关键字修饰的整型成员变量 `state`，它代表了**共享资源的状态**。所有同步机制都是围绕这个状态字段展开的。

*   **对于互斥锁**：`state = 0` 表示锁未被任何线程持有；`state = 1` 表示锁已被某个线程持有；`state > 1` 表示锁被同一个线程重入了多次（即可重入锁）。
*   **对于信号量（Semaphore）**：`state` 表示当前可用的许可（permits）数量。
*   **对于CountDownLatch**：`state` 表示计数器还未完成的次数。

对 `state` 的修改必须保证原子性，AQS 使用了 CAS（Compare-And-Swap）操作来确保这一点。

#### 2. 等待队列（CLH变体）
AQS 维护了一个**虚拟的双向链表队列**（CLH锁的变体），用于存放所有等待获取资源的线程。这个队列是“公平”的实现基础。

当一个线程尝试获取资源（比如锁）失败时，AQS 会将当前线程包装成一个**节点（Node）** 并将其加入队列的尾部，同时阻塞该线程（使用 `LockSupport.park()`）。当持有资源的线程释放资源时，它会唤醒（`LockSupport.unpark()`）队列中头节点的后继节点（如果存在），使其重新尝试获取资源。

#### 3. 两种资源共享模式
AQS 定义了两种资源访问模式：

*   **独占模式（Exclusive）**：同一时刻只有一个线程能成功获取资源并执行。例如：`ReentrantLock`。
*   **共享模式（Shared）**：同一时刻多个线程可以成功获取资源并执行。例如：`Semaphore`, `CountDownLatch`。

不同的同步器可以按需实现这两种模式。

#### 4. 模板方法设计模式
AQS 使用了**模板方法模式**。它本身是一个抽象类，但并没有定义任何抽象方法。它提供了大量诸如 `acquire`, `release`, `acquireShared`, `releaseShared` 等**模板方法**，这些方法内部调用了需要子类去覆盖和实现的**钩子方法（Hook Methods）**。

**需要子类实现的关键钩子方法：**

*   `tryAcquire(int arg)`：**独占式**尝试获取资源。成功返回 true，失败返回 false。
*   `tryRelease(int arg)`：**独占式**尝试释放资源。成功返回 true，失败返回 false。
*   `tryAcquireShared(int arg)`：**共享式**尝试获取资源。返回负数表示失败；0 表示成功，但后续共享获取不会再成功；正数表示成功，并且后续共享获取可能也会成功。
*   `tryReleaseShared(int arg)`：**共享式**尝试释放资源。如果释放后允许唤醒后续等待节点则返回 true，否则返回 false。
*   `isHeldExclusively()`：当前同步器是否被当前线程**独占**持有。

**工作流程（以独占模式的获取为例）：**
1.  用户调用 `lock.lock()`。
2.  `lock` 内部调用 AQS 的模板方法 `acquire(1)`。
3.  `acquire(1)` 首先会调用子类实现的 `tryAcquire(1)`。
4.  如果 `tryAcquire(1)` 成功（返回 true），则当前线程获取锁，流程结束。
5.  如果失败，AQS 会将当前线程加入等待队列并可能将其挂起。
6.  当队列中的线程被唤醒后，它会再次尝试调用 `tryAcquire(1)` 来获取资源。

通过这种方式，AQS 的模板方法处理了所有复杂的队列管理、阻塞与唤醒逻辑，而子类只需要关注如何通过 `state` 字段来判定资源能否被获取即可。

---

### 三、在 Android/Java 中的主要用途

AQS 是构建高级同步组件的基石，其在 Android 中的应用与在 Java 中完全一致，因为 Android 的并发工具类直接来源于 JDK。

以下是几个基于 AQS 的经典同步器：

1.  **ReentrantLock（可重入锁）**
    *   **用途**：一个标准的互斥锁，提供了比 `synchronized` 更灵活的锁操作（如可中断、超时、公平锁等）。
    *   **AQS 实现**：内部有一个 AQS 的子类 `Sync`。`state` 表示锁被重入的次数。`tryAcquire` 实现了重入逻辑。

2.  **ReentrantReadWriteLock（可重入读写锁）**
    *   **用途**：将锁分离为读锁和写锁，允许多个读操作同时进行，但写操作是独占的。提高了读多写少场景下的性能。
    *   **AQS 实现**：巧妙地使用一个 `state` 字段的高 16 位表示读锁的持有数，低 16 位表示写锁的重入次数。

3.  **Semaphore（信号量）**
    *   **用途**：控制同时访问特定资源的线程数量，用于流量控制。
    *   **AQS 实现**：`state` 表示当前可用的许可（permits）数量。`acquire()` 是获取许可（共享式），`release()` 是释放许可。

4.  **CountDownLatch（倒计时门闩）**
    *   **用途**：允许一个或多个线程等待其他线程完成操作。例如，主线程等待所有子线程初始化完成后再执行。
    *   **AQS 实现**：`state` 表示计数器初始值。`countDown()` 调用 `releaseShared` 使计数器减 1；`await()` 调用 `acquireShared`，直到计数器为 0 才被唤醒。

5.  **FutureTask**
    *   **用途**：表示一个异步计算任务。
    *   **AQS 实现**：内部使用 AQS 来管理任务的状态（未开始、运行中、完成、取消），并让获取结果的线程在任务未完成时进入等待队列。

---

### 四、总结

| 特性 | 描述 |
| :--- | :--- |
| **本质** | 一个用于构建锁和同步器的**框架**，采用**模板方法模式**。 |
| **核心** | 一个 volatile **`state`** 字段 + 一个 **FIFO 线程等待队列**。 |
| **关键操作** | 通过 **CAS** 操作原子性地更新 `state`；使用 **`LockSupport`** 进行线程的阻塞与唤醒。 |
| **两种模式** | **独占模式**（一次一个线程）和**共享模式**（一次多个线程）。 |
| **主要价值** | **分离了关注点**：同步器的实现者只需关注如何通过 `state` 管理资源的状态，而复杂的线程排队、阻塞/唤醒机制则由 AQS 在底层完成。这极大地简化了同步器的构造。 |
| **在Android中的角色** | Android 的并发编程模型与 Java 一致，AQS 是其 `java.util.concurrent` 包高效运行的基石，用于实现线程同步、任务协调等关键功能。 |

总而言之，AQS 是 Java 并发编程中一个非常强大且精巧的设计，理解了 AQS，就相当于掌握了 Java 并发包中大部分同步工具的工作原理。