# 什么是内存泄漏？如何检测并修复内存泄漏？

在Android开发中，内存泄漏（Memory Leak）是指**不再需要使用的对象仍然被其他对象持有强引用，导致垃圾回收器（GC）无法回收该对象所占用的内存**。随着泄漏对象累积，可用内存逐渐减少，可能引发内存溢出（OOM）、应用卡顿甚至崩溃。


### 常见的内存泄漏场景
1. **静态变量持有Activity/Context引用**  
   Activity是有生命周期的，若被静态变量（生命周期与应用一致）持有，即使Activity销毁，其内存也无法释放。  
   ```java
   public class MainActivity extends AppCompatActivity {
       // 静态变量持有Activity引用，导致泄漏
       private static MainActivity sInstance;
       
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           sInstance = this; // 危险！
       }
   }
   ```

2. **非静态内部类/匿名类持有外部类引用**  
   非静态内部类（如Handler、Thread、AsyncTask）默认持有外部类（通常是Activity）的引用。若内部类的生命周期长于外部类（如Handler发送的消息未处理完），会导致外部类无法回收。  
   ```java
   public class MainActivity extends AppCompatActivity {
       // 非静态Handler持有MainActivity引用
       private Handler mHandler = new Handler() {
           @Override
           public void handleMessage(Message msg) {
               // 处理消息
           }
       };
       
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           // 发送延迟消息，若Activity销毁前消息未处理，会导致泄漏
           mHandler.postDelayed(new Runnable() {
               @Override
               public void run() {}
           }, 10000);
       }
   }
   ```

3. **资源未及时释放**  
   未关闭的数据库连接（Cursor）、IO流、Bitmap、广播接收器（BroadcastReceiver）、监听器（Listener）等，若未在合适时机释放，会导致内存泄漏。

4. **单例模式持有Context**  
   单例的生命周期与应用一致，若持有Activity的Context（而非Application Context），会导致Activity无法回收。  


### 如何检测内存泄漏？
1. **Android Studio Memory Profiler**  
   内置工具，可实时监控应用内存使用情况，抓取堆转储（Heap Dump）分析对象引用关系：  
   - 打开`Profiler`面板（View > Tool Windows > Profiler），选择内存监控。  
   - 操作应用（如反复旋转屏幕，触发Activity销毁重建），观察内存是否持续增长。  
   - 点击“Dump Java Heap”生成堆转储文件，分析“Leaked Activities”等可疑对象的引用链。

2. **LeakCanary（推荐）**  
   Square开源的内存泄漏检测库，可自动检测并报告泄漏，集成简单：  
   - 在`build.gradle`中添加依赖：  
     ```gradle
     dependencies {
         debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.12'
     }
     ```  
   - 运行应用后，若发生泄漏，LeakCanary会在通知栏提示，并展示详细的引用链（如“MainActivity被Handler持有”）。

3. **MAT（Memory Analyzer Tool）**  
   强大的堆分析工具，可导入Android Profiler生成的堆转储文件（.hprof），通过“Dominator Tree”“Path to GC Roots”等功能定位泄漏根源。


### 如何修复内存泄漏？
针对常见场景，修复思路如下：

1. **避免静态变量持有Activity/Context**  
   - 若需使用Context，优先使用`Application Context`（生命周期与应用一致）。  
   - 静态变量在不需要时及时置为`null`。  
   ```java
   // 错误：持有Activity Context
   sContext = this; 
   // 正确：使用Application Context
   sContext = getApplicationContext(); 
   ```

2. **处理非静态内部类的引用问题**  
   - 将内部类改为**静态内部类**，并通过`WeakReference`持有外部类引用（避免强引用）。  
   - 生命周期长的组件（如Handler）在外部类销毁时清理资源（如移除未处理的消息）。  
   ```java
   public class MainActivity extends AppCompatActivity {
       // 静态内部类，不默认持有外部类引用
       private static class MyHandler extends Handler {
           private final WeakReference<MainActivity> mActivityRef;
           
           MyHandler(MainActivity activity) {
               mActivityRef = new WeakReference<>(activity);
           }
           
           @Override
           public void handleMessage(Message msg) {
               MainActivity activity = mActivityRef.get();
               if (activity != null) {
                   // 处理消息（需判断activity是否存活）
               }
           }
       }
       
       private MyHandler mHandler = new MyHandler(this);
       
       @Override
       protected void onDestroy() {
           super.onDestroy();
           mHandler.removeCallbacksAndMessages(null); // 移除所有消息
       }
   }
   ```

3. **及时释放资源**  
   - 数据库Cursor、IO流在`finally`块中关闭。  
   - Bitmap使用后调用`recycle()`（API 19+可自动回收，但建议显式处理）。  
   - 注册的广播、监听器在`onDestroy()`中取消注册。  

4. **单例模式优化**  
   单例若需Context，仅传入`Application Context`：  
   ```java
   public class MySingleton {
       private static MySingleton sInstance;
       private Context mContext;
       
       private MySingleton(Context context) {
           // 传入Application Context
           mContext = context.getApplicationContext();
       }
       
       public static synchronized MySingleton getInstance(Context context) {
           if (sInstance == null) {
               sInstance = new MySingleton(context);
           }
           return sInstance;
       }
   }
   ```


### 总结
内存泄漏的核心是“无用对象被强引用持有”。开发中需注意对象的生命周期匹配，优先使用弱引用管理临时对象，及时释放资源。借助LeakCanary等工具可高效定位问题，最终通过调整引用关系或清理资源解决泄漏。