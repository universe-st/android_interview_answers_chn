# 如何保证下载文件的完整性？

在Android开发中，保证下载文件的完整性需要结合**校验机制**、**断点续传**和**异常处理**等多种手段。以下是具体实现方案：


### 一、核心校验机制
文件完整性的核心是通过**校验值比对**确认文件未被篡改或损坏，常用方案：

#### 1. 哈希校验（推荐）
- 服务器在提供文件下载时，同时返回该文件的哈希值（如MD5、SHA-256），通常放在接口返回的元数据中。
- 客户端下载完成后，计算本地文件的哈希值，与服务器提供的哈希值比对，一致则说明文件完整。

**示例代码（计算文件SHA-256）：**
```java
public static String calculateFileSHA256(File file) {
    try (FileInputStream fis = new FileInputStream(file);
         BufferedInputStream bis = new BufferedInputStream(fis)) {
        
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] buffer = new byte[8192];
        int bytesRead;
        while ((bytesRead = bis.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead);
        }
        byte[] hashBytes = digest.digest();
        
        // 转换为十六进制字符串
        StringBuilder hexString = new StringBuilder();
        for (byte b : hashBytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}
```


#### 2. 文件大小校验（辅助）
- 先校验文件大小是否与服务器返回的一致（通过HTTP响应头`Content-Length`或接口元数据获取）。
- 若大小不一致，直接判定文件不完整，无需进行哈希计算，节省资源。

```java
// 服务器返回的文件大小（单位：字节）
long serverFileSize = ...;
// 本地文件大小
long localFileSize = new File(filePath).length();
if (localFileSize != serverFileSize) {
    // 文件大小不一致，不完整
    return false;
}
```


### 二、断点续传与分块下载
对于大文件，断点续传不仅能提高下载效率，还能减少因网络中断导致的文件损坏风险：

1. **原理**：通过HTTP的`Range`请求头，从已下载的字节位置继续下载，避免重复下载完整文件。
2. **实现**：
   - 记录已下载的字节数（如存在本地数据库或SharedPreferences）。
   - 下次请求时，在请求头中添加`Range: bytes=已下载字节数-`。
   - 下载过程中，使用`RandomAccessFile`按字节位置写入文件，避免覆盖已下载内容。

**示例代码（OkHttp实现断点续传）：**
```java
// 已下载的字节数
long downloadedBytes = getDownloadedBytes(filePath);
// 构建请求
Request request = new Request.Builder()
        .url(downloadUrl)
        .addHeader("Range", "bytes=" + downloadedBytes + "-") // 断点续传起始位置
        .build();

OkHttpClient client = new OkHttpClient();
client.newCall(request).enqueue(new Callback() {
    @Override
    public void onResponse(Call call, Response response) throws IOException {
        if (!response.isSuccessful()) {
            // 处理错误（如416 Range Not Satisfiable）
            return;
        }
        
        // 写入文件（从已下载位置继续）
        try (InputStream is = response.body().byteStream();
             RandomAccessFile raf = new RandomAccessFile(filePath, "rw")) {
             
            raf.seek(downloadedBytes); // 移动到已下载的末尾
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = is.read(buffer)) != -1) {
                raf.write(buffer, 0, bytesRead);
                // 实时更新已下载字节数（可选，用于断点记录）
                downloadedBytes += bytesRead;
                saveDownloadedBytes(filePath, downloadedBytes);
            }
        }
        
        // 下载完成后校验哈希
        String localHash = calculateFileSHA256(new File(filePath));
        if (localHash.equals(serverHash)) {
            // 校验通过，文件完整
        } else {
            // 校验失败，删除文件重新下载
            new File(filePath).delete();
        }
    }

    @Override
    public void onFailure(Call call, IOException e) {
        // 网络错误，重试或提示用户
    }
});
```


### 三、其他保障措施
1. **临时文件机制**：
   - 下载过程中先写入临时文件（如`xxx.tmp`），校验通过后再重命名为目标文件（如`xxx.apk`）。
   - 避免未完成的文件被误判为“完整文件”。

2. **重试机制**：
   - 针对网络波动，设置合理的重试次数（如3次）和重试间隔（如指数退避策略）。
   - 重试前检查临时文件是否存在，存在则继续断点续传。

3. **使用HTTPS**：
   - 防止下载过程中文件被中间人篡改（配合哈希校验双重保障）。

4. **校验时机**：
   - 若文件非常大（如1GB+），可分块下载时同步校验分块的哈希值，最后合并校验总哈希，减少失败时的重复下载量。


### 四、总结
保证文件完整性的核心流程是：  
`下载前获取元数据（大小+哈希）` → `支持断点续传下载` → `下载后校验大小+哈希` → `校验通过后确认文件完整`。  

通过这种组合方案，既能应对网络异常，又能有效防止文件损坏或篡改。