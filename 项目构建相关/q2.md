# compileOnly、implementation、api各有什么作用？

在Android Gradle构建中，`compileOnly`、`implementation`、`api` 是用于声明依赖的关键配置，它们决定了依赖的**可见性**、**传递性**以及对构建过程的影响，核心区别在于依赖的"暴露范围"和"构建效率"：


### 1. `compileOnly`（仅编译时依赖）
- **作用**：仅在**编译阶段**有效，依赖不会被打包到最终的APK/AAR中，运行时也不会存在。
- **适用场景**：
  - 依赖仅用于编译期（如编译时注解处理器、代码生成工具），运行时不需要。
  - 避免重复依赖（例如某个库已由宿主应用或其他模块提供，当前模块仅编译时需要引用其接口）。
- **举例**：  
  若使用 `compileOnly 'com.google.code.findbugs:jsr305:3.0.2'`，该库仅用于编译时注解校验（如`@Nullable`），不会被打包到APK中。


### 2. `implementation`（实现依赖，推荐默认使用）
- **作用**：依赖在**编译时和运行时均有效**，但**仅对当前模块可见**，不会传递给依赖当前模块的其他模块。
- **核心特点**：
  - 依赖"不暴露"：如果模块A用`implementation`依赖库X，那么依赖A的模块B**无法直接使用X**（需显式声明对X的依赖）。
  - 构建效率高：当库X更新时，仅需重新编译模块A，依赖A的模块B无需重新编译（因为B不知道X的存在）。
- **适用场景**：绝大多数内部依赖（当前模块自用，无需暴露给其他模块的库）。
- **举例**：  
  模块A用 `implementation 'com.squareup.okhttp3:okhttp:4.9.0'` 依赖OkHttp，模块B依赖A时，B中无法直接使用`okhttp3`相关类（需B自己声明依赖）。


### 3. `api`（接口依赖，原`compile`）
- **作用**：依赖在**编译时和运行时均有效**，且会**传递给依赖当前模块的其他模块**（即"暴露"给上层模块）。
- **核心特点**：
  - 依赖"可传递"：如果模块A用`api`依赖库X，那么依赖A的模块B**可以直接使用X**，无需重复声明。
  - 构建效率低：当库X更新时，模块A和所有依赖A的模块（如B）都需要重新编译（因为X的变化可能影响所有使用它的模块）。
- **适用场景**：库模块中需要"对外暴露"的依赖（例如模块A是一个工具库，其API返回值或参数类型来自库X，需让使用A的模块直接访问X）。
- **举例**：  
  模块A用 `api 'com.google.guava:guava:31.1-jre'` 依赖Guava，且A的方法返回`Guava`中的`ListMultimap`类型，那么依赖A的模块B可以直接使用`ListMultimap`（无需B自己声明Guava依赖）。


### 总结：核心区别与选择原则
| 配置        | 可见范围               | 是否传递给上层模块 | 构建效率 | 典型场景                     |
|-------------|------------------------|--------------------|----------|------------------------------|
| `compileOnly` | 仅当前模块编译时       | 否                 | 高       | 编译时工具、注解处理器       |
| `implementation` | 当前模块编译/运行时    | 否                 | 高       | 内部自用依赖（推荐默认）     |
| `api`       | 当前模块及所有依赖它的模块 | 是                 | 低       | 需暴露给上层的库接口依赖     |

**最佳实践**：  
- 优先使用 `implementation`（平衡封装性和构建效率）。  
- 仅在依赖需要"暴露给上层模块"时使用 `api`。  
- 编译时专用依赖用 `compileOnly`。