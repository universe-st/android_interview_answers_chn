# 异步消息

在Android开发中，**异步消息（Asynchronous Message）** 是一种特殊类型的消息，其核心特性是能够绕过消息队列中的**同步屏障（Sync Barrier）**，优先被处理。以下是其定义、特性及应用场景的详细解析：

### 一、异步消息的定义
异步消息是通过`Message.setAsynchronous(true)`标记的消息，其本质是**不受同步屏障阻塞的消息**。在消息队列中插入同步屏障后，所有同步消息会被临时阻塞，而异步消息仍可正常执行。例如，系统在触发UI绘制时会插入同步屏障，此时只有标记为异步的绘制消息能优先执行，确保界面流畅性。

### 二、核心特性
#### 1. **绕过同步屏障的优先级**
- **屏障机制**：同步屏障是一个`target`为`null`的特殊消息，插入队列后会阻塞后续所有同步消息。
- **异步豁免**：异步消息通过`isAsynchronous=true`标记，可跳过屏障直接执行。例如，View的`invalidate()`触发的绘制请求会被标记为异步，确保在屏障存在时优先处理。
- **系统级优先级**：Android框架内部（如`Choreographer`）广泛使用异步消息处理高优先级任务，如VSYNC信号触发的界面渲染。

#### 2. **独立于同步消息的执行顺序**
- **异步消息间有序**：异步消息在队列中按时间戳顺序执行，但可能早于队列中时间戳更早的同步消息。
- **与同步消息无序**：异步消息的执行顺序可能与同步消息交叉，例如：
  ```java
  // 同步屏障存在时：
  同步消息A（when=100ms） → 异步消息B（when=200ms） → 同步消息C（when=50ms）
  // 执行顺序：异步消息B → 同步消息C → 同步消息A（屏障移除后）
  ```
  这种机制确保关键任务（如动画）不会被普通同步消息阻塞。

#### 3. **标记方式的灵活性**
- **显式标记**：通过`Message.setAsynchronous(true)`直接设置。
- **隐式标记**：创建`Handler`时传入`async=true`，其发送的所有消息默认标记为异步：
  ```java
  Handler asyncHandler = new Handler(Looper.getMainLooper(), true);
  asyncHandler.sendMessage(msg); // 自动标记为异步
  ```

#### 4. **单向通信与非阻塞性**
- **发送即继续**：异步消息发送后，发送方无需等待执行结果，可立即处理其他任务。例如，输入事件处理线程发送异步消息后，无需阻塞等待UI线程响应。
- **适用场景**：适用于时效性强但无需返回结果的任务，如动画帧更新、触摸事件响应等。

#### 5. **与同步消息的互补性**
- **同步消息的默认性**：未标记的消息默认是同步的，按时间戳顺序执行。
- **协作机制**：异步消息用于紧急任务，同步消息用于常规操作。例如，网络请求结果通过同步消息更新UI，而触摸事件通过异步消息立即响应。

### 三、实现机制与代码示例
#### 1. **消息队列的处理逻辑**
`MessageQueue.next()`方法在同步屏障存在时，会跳过同步消息，优先查找异步消息：
```java
// MessageQueue.next()核心逻辑
if (msg.target == null) { // 遇到同步屏障
    do {
        prevMsg = msg;
        msg = msg.next;
    } while (msg != null && !msg.isAsynchronous()); // 找到首个异步消息
}
return msg; // 返回异步消息，同步消息被阻塞
```
此逻辑确保异步消息在屏障存在时优先执行。

#### 2. **开发者使用示例**
- **显式设置异步消息**：
  ```java
  Message asyncMsg = Message.obtain();
  asyncMsg.setAsynchronous(true);
  asyncMsg.what = MSG_UPDATE_ANIMATION;
  handler.sendMessage(asyncMsg);
  ```
- **系统级异步消息（UI绘制）**：
  ```java
  // ViewRootImpl中的绘制流程
  mTraversalBarrier = mHandler.getLooper().postSyncBarrier(); // 插入屏障
  mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); // 异步绘制消息
  // 绘制完成后移除屏障
  mHandler.getLooper().removeSyncBarrier(mTraversalBarrier);
  ```
  这里，`mTraversalRunnable`会被标记为异步，确保在屏障存在时优先执行。

### 四、适用场景
1. **UI渲染与动画**：  
   - 例如，`View.invalidate()`触发的绘制请求通过异步消息绕过屏障，确保60fps帧率。
2. **输入事件处理**：  
   - 触摸事件通过异步消息立即响应，避免被其他同步任务阻塞。
3. **系统级中断任务**：  
   - 如VSYNC信号、ANR监测等需要优先处理的系统事件。
4. **高优先级后台任务**：  
   - 例如，视频解码完成后通过异步消息通知UI更新，无需等待其他同步消息。

### 五、注意事项与最佳实践
1. **避免滥用异步消息**：  
   - 异步消息可能导致同步消息长时间阻塞，引发ANR。仅在必要时（如动画、输入事件）使用。
2. **屏障的成对使用**：  
   - 插入同步屏障后必须显式移除，否则同步消息永久阻塞：
     ```java
     int token = queue.postSyncBarrier();
     // 任务完成后
     queue.removeSyncBarrier(token);
     ```
     系统内部（如`ViewRootImpl`）会自动管理屏障，但开发者手动插入时需特别注意。
3. **异步消息的时间戳控制**：  
   - 通过`sendMessageAtTime`设置合理的`when`值，避免异步消息过早或过晚执行。
4. **异步消息的顺序性考量**：  
   - 若任务间存在依赖关系，需通过同步机制（如`CountDownLatch`）保证顺序，而非依赖异步消息自身顺序。

### 六、总结
异步消息是Android消息机制中实现优先级调度的核心工具，其核心价值在于**通过同步屏障豁免权确保关键任务优先执行**。开发者应根据场景合理标记异步消息，避免滥用导致同步消息阻塞，同时结合时间戳控制和屏障管理，实现高效的任务调度。