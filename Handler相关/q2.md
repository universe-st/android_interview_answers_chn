# Messagequeue的数据结构是什么？为什么要用这个数据结构？

在Android中，`MessageQueue`（消息队列）的底层数据结构是**单链表**，而非传统意义上的队列（如数组实现的队列）。每个`Message`对象通过其`next`字段指向链表中的下一个消息，从而形成链式结构。


### 为什么选择单链表作为数据结构？
`MessageQueue`的核心功能是**按时间顺序管理消息**（包括立即执行的消息和延迟消息），并支持高效的插入、删除操作。单链表结构恰好适配了这些需求，具体原因如下：


#### 1. 高效支持“按时间排序”的插入操作
`MessageQueue`中的消息并非简单的“先进先出”，而是需要**按`when`字段（消息触发时间）排序**：  
- 立即执行的消息（`when=0`）排在前面；  
- 延迟消息（如`postDelayed`发送的消息）按`when`的大小（时间戳）依次排列，确保Looper优先处理最早到期的消息。  

当插入新消息时，需要遍历链表找到第一个`when`大于当前消息`when`的位置，然后插入到其前面。单链表的插入操作只需修改前后节点的`next`指针（时间复杂度为`O(1)`，仅需遍历找到位置的时间`O(n)`），而如果使用数组：  
- 插入中间位置需要移动后续所有元素（时间复杂度`O(n)`），效率更低；  
- 数组容量固定，动态扩容会导致额外的内存开销。  


#### 2. 高效支持消息的“移除”操作
`MessageQueue`需要频繁处理消息移除场景：  
- 主动移除（如`handler.removeCallbacksAndMessages(null)`）；  
- 消息处理完成后自动移除；  
- 延迟消息未执行前被取消。  

单链表的移除操作同样只需修改前后节点的`next`指针（`O(1)`），而数组移除中间元素需要移动后续元素（`O(n)`），效率差异明显。  


#### 3. 内存友好，适合频繁复用
`Message`对象通过`Message.obtain()`从消息池复用（避免频繁`new`导致的内存碎片），单链表结构天然适合这种“动态复用”场景：  
- 链表节点（`Message`）不需要连续的内存空间，内存分配更灵活；  
- 复用消息时，只需修改`next`指针即可重新加入链表，操作轻量化。  


#### 4. 适配“消息优先级动态变化”
虽然`Message`的`when`字段在插入后通常不变，但某些场景下（如系统消息优先级调整）可能需要动态修改顺序。单链表的结构允许通过调整指针快速改变节点位置，而数组需要大量元素移动，成本过高。  


### 总结
`MessageQueue`选择单链表作为数据结构，是为了适配其核心需求：**按时间排序管理消息，并支持高效的插入、删除和复用操作**。单链表在内存效率、动态操作灵活性上的优势，远胜于数组或双链表等结构，使其成为Android消息循环机制的最优选择。