# 请说一说HashMap，SparseArrary原理，SparseArrary相比HashMap的优点。

### 一、HashMap 原理

#### 1. 数据结构与核心机制
- **数组+链表/红黑树**：  
  HashMap 内部通过数组存储键值对，每个数组元素称为一个桶（Bucket）。当键通过哈希函数映射到桶的位置后，若桶中已有元素（哈希冲突），则使用链表或红黑树（JDK 1.8 后）连接冲突元素。例如，键 `key` 的哈希值为 `hash`，桶的索引为 `index = hash & (length - 1)`。  
- **哈希函数与负载因子**：  
  哈希函数通过 `key.hashCode()` 计算，并进行扰动处理（`hash ^ (hash >>> 16)`）以减少哈希冲突。负载因子（默认 0.75）控制扩容时机：当元素数量超过 `容量 × 负载因子` 时，数组扩容为原来的 2 倍，并重新哈希所有元素。  
- **红黑树优化**：  
  JDK 1.8 后，当链表长度超过 8 且数组容量 ≥ 64 时，链表会转换为红黑树以提高查询效率（时间复杂度从 O(n) 降至 O(log n)）。

#### 2. 扩容与性能特点
- **扩容代价**：  
  扩容时需重建哈希表，导致 O(n) 时间复杂度，因此初始容量设置不当可能影响性能。  
- **线程不安全**：  
  HashMap 非线程安全，多线程环境下需使用 `ConcurrentHashMap` 或手动同步。  
- **内存开销**：  
  每个 Entry 对象包含哈希值、键、值和链表指针，内存占用较高。例如，一个 Entry 对象在 64 位系统中约占 32 字节。

### 二、SparseArray 原理

#### 1. 数据结构与核心机制
- **双数组存储**：  
  SparseArray 使用两个数组 `mKeys`（int 类型）和 `mValues`（Object 类型）分别存储键和值。键按升序排列，通过二分查找定位索引，时间复杂度为 O(log n)。  
- **二分查找定位**：  
  插入或查询时，通过 `ContainerHelpers.binarySearch` 方法在 `mKeys` 中查找键的位置。若键不存在，返回 `~lo`（`lo` 为应插入的位置）。  
- **延迟 GC 机制**：  
  删除元素时，仅将 `mValues` 对应位置标记为 `DELETED`，并设置 `mGarbage = true`。GC 操作（整理数组）在后续插入、扩容或获取大小（`size()`）时触发，避免频繁数组拷贝。  
- **扩容策略**：  
  初始容量为 10，当元素数量超过当前容量时，扩容为当前容量的 2 倍（若当前容量 ≤ 4，则扩容为 8）。扩容时通过 `System.arraycopy` 复制数组。

#### 2. 内存与性能特点
- **避免自动装箱**：  
  键直接存储为 int 类型，避免了 HashMap 中 `Integer` 对象的装箱拆箱开销，提升性能并减少内存占用。  
- **内存效率**：  
  无 Entry 对象和哈希表额外开销，内存占用比 HashMap 低 30%-35%。例如，存储 10 万条数据时，SparseArray 比 HashMap 节省约 4.6MB 内存。  
- **线程不安全**：  
  与 HashMap 类似，SparseArray 非线程安全，多线程环境需同步。

### 三、SparseArray 相比 HashMap 的核心优点

#### 1. **内存效率显著提升**
- **避免对象开销**：  
  SparseArray 无需存储哈希值、链表指针等额外信息，每个键值对仅需两个基本类型数组的存储空间。例如，存储 10 万条 `int -> Object` 数据时，SparseArray 内存占用约为 8.6MB，而 HashMap 需 13.2MB（节省 35%）。  
- **无负载因子浪费**：  
  HashMap 为减少哈希冲突，需预留 25% 的空间（负载因子 0.75），而 SparseArray 可完全利用数组空间。

#### 2. **避免自动装箱拆箱**
- **性能优化**：  
  直接使用 int 类型键，避免了 `Integer` 对象的创建和销毁。例如，在 10 万次插入操作中，SparseArray 比 HashMap 快约 30%。

#### 3. **稀疏数据场景更高效**
- **二分查找优势**：  
  当键分布稀疏（如大量非连续整数）时，SparseArray 的二分查找效率接近 HashMap 的 O(1) 哈希查找，且无需处理哈希冲突。  
- **插入顺序无关性**：  
  SparseArray 按键升序存储，插入顺序不影响查询效率；而 HashMap 的哈希分布可能导致链表过长，影响性能。

#### 4. **适用于 Android 平台**
- **Android 特化设计**：  
  SparseArray 是 Android 框架特有的类，针对移动设备内存受限的场景优化，官方推荐在键为 int 且数据量较小（千级以下）时使用。  
- **避免 OOM 风险**：  
  内存节省特性降低了因内存不足导致的 `OutOfMemoryError` 风险，尤其在列表、缓存等场景中效果显著。

### 四、适用场景与局限性

#### 1. **推荐使用 SparseArray 的场景**
- **键为 int 类型**：  
  如资源 ID、索引、枚举值等。  
- **数据量较小**：  
  官方建议数据量在数百以下时性能差异不超过 50%，千级以下仍可接受。  
- **内存敏感场景**：  
  如 Android 应用中的列表适配器、缓存映射等。

#### 2. **SparseArray 的局限性**
- **不支持泛型**：  
  值类型为 Object，需手动强制类型转换。  
- **数据量大时性能下降**：  
  当数据量超过千级时，二分查找的时间复杂度（O(log n)）可能超过 HashMap 的平均 O(1) 时间。  
- **非线程安全**：  
  多线程环境下需自行同步或使用 `ConcurrentHashMap`。

#### 3. **与其他数据结构的对比**
- **与 ArrayMap 对比**：  
  ArrayMap 适用于键为非 int 类型且数据量较小的场景，而 SparseArray 专为 int 键优化，内存更优。  
- **与 HashMap 对比**：  
  | 特性                | HashMap                          | SparseArray                     |
  |---------------------|----------------------------------|---------------------------------|
  | 键类型              | 任意对象                         | 仅限 int                        |
  | 内存占用            | 高（含 Entry 对象开销）         | 低（双数组存储）               |
  | 自动装箱            | 需要（键为 int 时）             | 不需要                         |
  | 数据量适用性        | 无限制                           | 千级以下                       |
  | 线程安全性          | 非线程安全                       | 非线程安全                     |

### 五、总结
SparseArray 是 Android 平台针对 int 键优化的高效数据结构，通过双数组和二分查找实现内存与性能的平衡。相比 HashMap，其核心优势在于**内存节省 30%-35%**、**避免装箱拆箱**以及**稀疏数据场景的高效查询**。然而，其局限性也很明显：键类型受限、数据量大时性能下降、非线程安全。因此，在键为 int 且数据量较小的场景中，SparseArray 是替代 HashMap 的理想选择；而在通用场景或数据量较大时，HashMap 仍是更优方案。