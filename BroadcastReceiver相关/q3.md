# 有序广播和无序广播的核心区别是什么？如何发送和接收有序广播？

在Android中，**有序广播（Ordered Broadcast）** 和**无序广播（Normal Broadcast）** 是两种不同的广播传递机制，核心区别体现在**接收顺序、数据交互和拦截能力**上。


### 一、核心区别
| 特性               | 无序广播（Normal Broadcast）                          | 有序广播（Ordered Broadcast）                          |
|--------------------|------------------------------------------------------|-------------------------------------------------------|
| **接收顺序**       | 所有接收器同时接收（无固定顺序）                      | 按接收器的**优先级**依次接收（优先级高的先处理）        |
| **数据修改**       | 接收器无法修改广播中的数据                            | 高优先级接收器可修改数据，低优先级接收器接收修改后的数据 |
| **拦截能力**       | 无法拦截，所有接收器都会收到                          | 高优先级接收器可调用`abortBroadcast()`拦截，后续接收器无法接收 |
| **传递效率**       | 效率高（异步传递）                                    | 效率较低（同步传递，需等待前一个接收器处理完毕）        |
| **适用场景**       | 只需通知多个组件，无需交互或顺序处理（如通知系统事件）  | 需要按顺序处理、数据交互或可能需要拦截的场景（如短信拦截、权限验证） |


### 二、如何发送和接收有序广播
#### 1. 发送有序广播
通过`Context.sendOrderedBroadcast()`方法发送，需指定广播Action、权限（可选）、结果接收器（可选）等参数。

**方法原型**：
```java
sendOrderedBroadcast(
    Intent intent,          // 广播意图（包含Action等信息）
    String receiverPermission,  // 接收者需声明的权限（null表示无权限限制）
    BroadcastReceiver resultReceiver,  // 最终的结果接收器（即使被拦截也会收到）
    Handler scheduler,      // 处理结果的Handler（null表示主线程）
    int initialCode,        // 初始结果码
    String initialData,     // 初始数据
    Bundle initialExtras    // 初始额外数据
)
```

**发送示例**：
```java
// 1. 创建广播意图，指定Action
Intent intent = new Intent("com.example.ORDERED_BROADCAST_ACTION");
// 可选：携带初始数据
intent.putExtra("data", "原始数据");

// 2. 发送有序广播
sendOrderedBroadcast(
    intent,
    "com.example.RECEIVE_PERMISSION",  // 接收者需声明此权限
    new FinalReceiver(),  // 最终结果接收器（无论是否被拦截都会触发）
    null,  // 使用主线程处理
    Activity.RESULT_OK,  // 初始结果码
    "初始数据",  // 初始数据
    null  // 无额外数据
);

// 最终结果接收器（可选）
class FinalReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 即使广播被拦截，此接收器仍会收到通知
        String resultData = getResultData(); // 获取最终数据
        Toast.makeText(context, "最终结果：" + resultData, Toast.LENGTH_SHORT).show();
    }
}
```


#### 2. 接收有序广播
需在注册接收器时**设置优先级**（通过`intent-filter`的`priority`属性，范围：-1000~1000，值越高优先级越高），并在`onReceive()`中处理数据或拦截广播。

**步骤1：创建接收器并处理广播**
```java
// 高优先级接收器（例如：优先级100）
public class HighPriorityReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 1. 获取广播数据
        String originalData = getResultData(); // 获取上一级传递的数据（或初始数据）
        Bundle extras = getResultExtras(true); // 获取额外数据
        
        // 2. 处理数据（例如：修改数据）
        String modifiedData = originalData + "（已被高优先级接收器处理）";
        setResultData(modifiedData); // 更新数据，传递给下一级接收器
        
        // 3. 可选：拦截广播（后续低优先级接收器将无法接收）
        // abortBroadcast(); 
    }
}

// 低优先级接收器（例如：优先级50）
public class LowPriorityReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 接收高优先级接收器修改后的数据
        String data = getResultData();
        Toast.makeText(context, "低优先级接收器收到：" + data, Toast.LENGTH_SHORT).show();
    }
}
```

**步骤2：注册接收器（指定优先级）**  
可通过静态注册（`AndroidManifest.xml`）或动态注册（代码），需明确`priority`。

**静态注册示例**：
```xml
<!-- 高优先级接收器 -->
<receiver android:name=".HighPriorityReceiver">
    <intent-filter android:priority="100"> <!-- 优先级100 -->
        <action android:name="com.example.ORDERED_BROADCAST_ACTION" />
    </intent-filter>
</receiver>

<!-- 低优先级接收器 -->
<receiver android:name=".LowPriorityReceiver">
    <intent-filter android:priority="50"> <!-- 优先级50 -->
        <action android:name="com.example.ORDERED_BROADCAST_ACTION" />
    </intent-filter>
</receiver>

<!-- 声明接收权限（若发送时指定了权限） -->
<uses-permission android:name="com.example.RECEIVE_PERMISSION" />
```

**动态注册示例**：
```java
// 在Activity中注册
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    
    // 高优先级接收器
    HighPriorityReceiver highReceiver = new HighPriorityReceiver();
    IntentFilter highFilter = new IntentFilter("com.example.ORDERED_BROADCAST_ACTION");
    highFilter.setPriority(100); // 设置优先级
    registerReceiver(highReceiver, highFilter);
    
    // 低优先级接收器
    LowPriorityReceiver lowReceiver = new LowPriorityReceiver();
    IntentFilter lowFilter = new IntentFilter("com.example.ORDERED_BROADCAST_ACTION");
    lowFilter.setPriority(50); // 设置优先级
    registerReceiver(lowReceiver, lowFilter);
}

// 务必在onDestroy()中注销
@Override
protected void onDestroy() {
    super.onDestroy();
    unregisterReceiver(highReceiver);
    unregisterReceiver(lowReceiver);
}
```


### 三、关键注意事项
1. **优先级规则**：  
   - 优先级越高的接收器越先接收广播；  
   - 若优先级相同，静态注册的接收器可能比动态注册的先接收（具体顺序依赖系统实现）。

2. **数据传递**：  
   - 高优先级接收器可通过`setResultData(String)`、`setResultExtras(Bundle)`修改数据，低优先级接收器通过`getResultData()`、`getResultExtras()`获取修改后的数据。

3. **拦截广播**：  
   - 调用`abortBroadcast()`后，后续接收器（包括同优先级）将无法接收，但`sendOrderedBroadcast()`中指定的`resultReceiver`仍会收到通知。

4. **权限控制**：  
   - 发送时指定`receiverPermission`，则只有声明了该权限的应用才能接收此广播，增强安全性。

5. **适用场景**：  
   - 有序广播适合需要“链式处理”或“权限校验”的场景，例如：短信发送流程（先经系统验证，再到应用处理）、事件审核（高权限组件先审核，通过后再传递）等。


通过以上方式，即可实现有序广播的发送与接收，利用其顺序性和交互能力处理复杂的跨组件通信场景。