# C++中的多态是如何实现的？为什么调用基类指针的虚方法会访问到派生类的函数？

在C++中，多态（动态多态）的实现核心依赖于**虚函数机制**，具体通过**虚函数表（vtable）** 和**虚表指针（vptr）** 实现。以下是详细解释：


### 1. 多态的实现原理：虚函数表与虚表指针
当类中声明了虚函数（用`virtual`关键字修饰）时，C++编译器会为该类生成一个**虚函数表（vtable）**——这是一个存储该类所有虚函数地址的数组。  
同时，该类的每个对象都会隐含一个**虚表指针（vptr）**，这个指针会在对象创建时自动初始化，指向所属类的虚函数表。

- 对于基类：如果基类声明了虚函数，编译器会为基类生成一个vtable，存储基类自身的虚函数地址。
- 对于派生类：当派生类继承基类并**重写（override）** 基类的虚函数时，派生类会生成自己的vtable。派生类的vtable中，会先包含基类vtable的所有内容，然后用自身重写的虚函数地址**替换**基类对应虚函数的地址（未重写的虚函数仍保持基类的地址）。


### 2. 为什么基类指针调用虚方法会访问到派生类的函数？
当使用**基类指针（或引用）指向派生类对象**时，这个指针虽然类型是基类，但它实际指向的是派生类对象的内存空间。  
而派生类对象的**vptr指向的是派生类自己的vtable**（而非基类的vtable）。  

当通过基类指针调用虚函数时，程序的执行流程是：  
1. 通过基类指针找到所指向对象的vptr；  
2. 通过vptr找到该对象所属类（派生类）的vtable；  
3. 在vtable中找到对应虚函数的地址（由于派生类重写了该函数，地址已被替换为派生类的实现）；  
4. 调用该地址对应的函数（即派生类的实现）。  


### 示例说明
```cpp
#include <iostream>
using namespace std;

// 基类
class Base {
public:
    // 声明虚函数
    virtual void func() { 
        cout << "Base::func()" << endl; 
    }
};

// 派生类，重写基类的虚函数
class Derived : public Base {
public:
    // 重写虚函数（可省略virtual，但建议加上）
    void func() override { 
        cout << "Derived::func()" << endl; 
    }
};

int main() {
    Base* ptr = new Derived(); // 基类指针指向派生类对象
    ptr->func(); // 调用的是派生类的func()，输出 "Derived::func()"
    delete ptr;
    return 0;
}
```

在这个例子中：  
- `Base`类的vtable存储`Base::func()`的地址；  
- `Derived`类的vtable中，`func()`的地址被替换为`Derived::func()`；  
- 基类指针`ptr`指向`Derived`对象，其vptr指向`Derived`的vtable，因此调用`ptr->func()`时，最终执行的是派生类的实现。


### 总结
C++多态的本质是通过**虚函数表（vtable）** 存储虚函数地址，通过**虚表指针（vptr）** 关联对象与所属类的vtable。当基类指针指向派生类对象时，借助vptr找到派生类的vtable，从而调用派生类重写的虚函数，实现“同一接口，不同实现”的多态效果。