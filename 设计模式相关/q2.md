# 责任链模式

### 责任链模式（Chain of Responsibility Pattern）定义  
责任链模式是一种行为型设计模式，其核心思想是：**将请求的处理者通过“链”的形式串联起来，请求沿着链依次传递，每个处理者可选择处理请求或传递给下一个处理者，直到请求被处理或链结束**。  

它的核心角色包括：  
- **抽象处理者（Handler）**：定义处理请求的接口，包含一个指向“下一个处理者”的引用。  
- **具体处理者（ConcreteHandler）**：实现抽象处理者的接口，判断是否处理当前请求，若不处理则传递给下一个处理者。  


### Android开发中的责任链模式实例  

#### 1. View事件分发机制（最典型实例）  
Android中View的触摸事件（如点击、滑动）传递是责任链模式的经典应用。事件从上层容器到下层View依次传递，每个层级可决定“消费事件”或“传递给子View”。  

- **抽象处理者**：`View`类（通过`dispatchTouchEvent()`方法定义事件传递接口，内部持有子View的引用作为“下一个处理者”）。  
- **具体处理者**：`Activity`、`ViewGroup`、`View`等。  

**事件传递流程**：  
1. 事件先到达`Activity`的`dispatchTouchEvent()`，它将事件传递给顶层`ViewGroup`；  
2. `ViewGroup`通过`dispatchTouchEvent()`判断是否拦截（`onInterceptTouchEvent()`）：  
   - 若拦截，由自身的`onTouchEvent()`处理；  
   - 若不拦截，传递给子`View`；  
3. 子`View`的`dispatchTouchEvent()`会调用自身`onTouchEvent()`：  
   - 若`onTouchEvent()`返回`true`（消费事件），事件终止；  
   - 若返回`false`，事件回传至上一层处理。  

**代码简化示例**：  
```java
// 抽象处理者（简化）
public abstract class View {
    protected View mChild; // 下一个处理者（子View）
    
    public boolean dispatchTouchEvent(MotionEvent event) {
        boolean handled = false;
        if (onTouchEvent(event)) { // 自身处理
            handled = true;
        } else if (mChild != null) { // 传递给子View
            handled = mChild.dispatchTouchEvent(event);
        }
        return handled;
    }
    
    public abstract boolean onTouchEvent(MotionEvent event);
}

// 具体处理者（ViewGroup）
public class ViewGroup extends View {
    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        if (onInterceptTouchEvent(event)) { // 拦截事件
            return onTouchEvent(event);
        } else { // 不拦截，传递给子View
            return super.dispatchTouchEvent(event);
        }
    }
    
    public boolean onInterceptTouchEvent(MotionEvent event) {
        // 决定是否拦截（如ScrollView滑动时拦截子View点击）
        return false;
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // 处理事件（如ViewGroup自身的点击）
        return false;
    }
}
```  


#### 2. 有序广播（Ordered Broadcast）  
Android的有序广播是责任链模式的另一种体现，广播按优先级依次传递给接收者，每个接收者可终止广播。  

- **抽象处理者**：`BroadcastReceiver`（通过`onReceive()`定义处理接口，系统维护接收者优先级链）。  
- **具体处理者**：注册的有序广播接收者（按`priority`属性排序）。  

**流程**：  
1. 发送有序广播：`context.sendOrderedBroadcast(intent, permission)`；  
2. 广播按优先级从高到低传递给`BroadcastReceiver`；  
3. 接收者可通过`abortBroadcast()`终止广播，后续接收者不再收到。  


#### 3. OkHttp拦截器（Interceptor Chain）  
OkHttp是Android常用的网络库，其拦截器链完全基于责任链模式设计：  

- **抽象处理者**：`Interceptor`接口（定义`intercept(Chain chain)`方法，`Chain`持有下一个拦截器引用）。  
- **具体处理者**：`RetryAndFollowUpInterceptor`、`BridgeInterceptor`、`CacheInterceptor`等。  

**流程**：  
1. 请求从第一个拦截器开始（如重试拦截器）；  
2. 每个拦截器处理后（如添加请求头、处理缓存），通过`chain.proceed(request)`传递给下一个拦截器；  
3. 最终到达服务器，响应沿链反向返回，每个拦截器可处理响应（如解析缓存）。  


### 责任链模式的优缺点  

#### 优点  
1. **降低耦合度**：请求发送者无需知道具体处理者，只需将请求投入链中，符合“迪米特法则”。  
   - 例：View事件分发中，`Activity`无需知道事件最终由哪个`Button`处理。  
2. **灵活性高**：可动态调整链的顺序或增减处理者，无需修改发送者代码。  
   - 例：OkHttp可通过`addInterceptor()`自由添加自定义拦截器。  
3. **符合开闭原则**：新增处理者只需实现接口并加入链中，无需修改现有代码。  


#### 缺点  
1. **请求可能无人处理**：若链中所有处理者都不处理请求，可能导致请求“丢失”（需额外逻辑避免）。  
   - 例：若所有View都不消费事件，事件最终会被`Activity`处理（默认返回false，无实际操作）。  
2. **性能风险**：链过长时，请求传递会增加耗时，且调试难度提高（需跟踪整个链的传递路径）。  
   - 例：复杂布局的View事件分发若链过长，可能影响滑动流畅度。  


### 总结  
责任链模式在Android中应用广泛，核心价值是解耦请求发送与处理，通过“链式传递”实现灵活的分工。但需注意控制链的长度，避免性能问题，并确保请求有明确的最终处理者。