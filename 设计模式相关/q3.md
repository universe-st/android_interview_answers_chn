# 建造者模式

### 建造者模式（Builder Pattern）的定义  
建造者模式是一种创建型设计模式，其核心思想是**将复杂对象的构建过程与它的表示分离**，使得同样的构建过程可以创建不同的表示。  

简单来说，当一个对象包含多个组成部分（且部分组件可选），构建过程复杂且需要灵活配置时，建造者模式通过一个“建造者（Builder）”类分步构造对象，最终由“指挥者（Director）”或客户端触发构建完成，从而简化复杂对象的创建过程。


### Android开发中的建造者模式实例  
在Android开发中，**`AlertDialog.Builder`** 是建造者模式的经典应用。  

`AlertDialog` 是一个复杂对象，它可能包含标题、消息、图标、确认按钮、取消按钮、输入框等多个可选组件。如果通过构造函数创建，会因参数过多导致代码混乱（“ telescoping constructor ”问题）。而 `AlertDialog.Builder` 通过链式调用分步配置这些组件，最终构建出 `AlertDialog` 对象。

示例代码：  
```kotlin
// 使用建造者模式创建AlertDialog
AlertDialog.Builder(context)
    .setTitle("提示")                // 设置标题（可选）
    .setMessage("确定要删除吗？")    // 设置消息（可选）
    .setIcon(R.drawable.ic_warning)  // 设置图标（可选）
    .setPositiveButton("确定") { dialog, _ -> 
        // 确认按钮逻辑
        dialog.dismiss()
    }
    .setNegativeButton("取消") { dialog, _ -> 
        // 取消按钮逻辑
        dialog.dismiss()
    }
    .create()  // 构建AlertDialog对象
    .show()    // 显示对话框
```

在这个例子中：  
- `AlertDialog` 是“产品（Product）”：最终被创建的复杂对象。  
- `AlertDialog.Builder` 是“建造者（Builder）”：提供一系列方法（`setTitle`、`setMessage` 等）分步配置产品的组件。  
- 客户端通过 `create()` 方法触发最终构建，得到 `AlertDialog` 对象。  


### 建造者模式的优缺点  

#### 优点：  
1. **灵活性高**：支持分步构建对象，可选组件可按需配置，无需关注构建顺序。  
   例如 `AlertDialog` 可以只设置标题和确认按钮，也可以同时设置所有组件。  

2. **代码可读性强**：链式调用（`builder.xxx().yyy().zzz()`）让配置过程清晰直观，比多参数构造函数更易维护。  

3. **封装性好**：隐藏了复杂对象的构建细节，客户端无需知道 `AlertDialog` 的内部结构（如布局如何组合），只需通过 `Builder` 接口配置即可。  

4. **便于扩展**：如果需要新增 `AlertDialog` 的组件（如添加一个“中立按钮”），只需在 `Builder` 中新增一个 `setNeutralButton` 方法，无需修改现有逻辑。  


#### 缺点：  
1. **增加代码量**：需要额外定义 `Builder` 类，对于简单对象（如只有2-3个固定属性的类），会显得冗余。  

2. **学习成本**：对新手而言，理解“产品-建造者”的分离逻辑需要一定时间，不如直接使用构造函数直观。  

3. **构建过程不可变**：一旦通过 `create()` 生成对象，若需修改属性，通常需要重新通过 `Builder` 构建（部分场景可通过对象的 `setter` 弥补，但违背建造者模式的设计初衷）。  


### 总结  
建造者模式特别适合创建**具有多个可选组件的复杂对象**，在Android中除了 `AlertDialog.Builder`，还广泛应用于 `Notification.Builder`、`Retrofit` 的请求配置等场景。其核心价值是通过分步构建和链式调用，平衡了复杂对象的灵活性与代码的可读性。