# 有几种类加载器？它们的作用是什么？

在Java中，类加载器（ClassLoader）是负责将类的字节码（.class文件）加载到JVM中的组件。Java中主要有以下几类核心类加载器，它们按照“双亲委派模型”协同工作：


### 1. 启动类加载器（Bootstrap ClassLoader）
- **实现方式**：由C/C++语言实现（非Java代码），是JVM的一部分。
- **作用**：负责加载Java核心类库（JRE的lib目录下的核心类，如`rt.jar`、`resources.jar`等），这些类是JVM运行的基础（如`java.lang.Object`、`java.lang.String`等）。
- **特点**：  
  - 没有父加载器，是类加载器层级的最顶层。  
  - 只加载包名为`java`、`javax`、`sun`等开头的核心类。  
  - 无法通过Java代码直接获取其实例（`getClassLoader()`方法返回`null`）。


### 2. 扩展类加载器（Extension ClassLoader）
- **实现方式**：由Java代码实现（`sun.misc.Launcher$ExtClassLoader`类）。
- **作用**：负责加载Java扩展类库（JRE的`lib/ext`目录下的类，或通过系统属性`java.ext.dirs`指定的目录中的类）。这些类是对核心类库的扩展（如一些第三方提供的扩展功能）。
- **特点**：父加载器是启动类加载器（逻辑上）。


### 3. 应用程序类加载器（Application ClassLoader）
- **实现方式**：由Java代码实现（`sun.misc.Launcher$AppClassLoader`类）。
- **作用**：负责加载用户类路径（classpath）上的类，包括我们自己编写的Java类、第三方依赖的jar包等。这是开发中最常用的类加载器。
- **特点**：  
  - 父加载器是扩展类加载器。  
  - 可以通过`ClassLoader.getSystemClassLoader()`方法获取其实例（因此也称为“系统类加载器”）。


### 4. 自定义类加载器（User-Defined ClassLoader）
- **实现方式**：通过继承Java提供的`ClassLoader`类（或其子类），重写`findClass()`等方法实现自定义加载逻辑。
- **作用**：满足特殊的类加载需求，例如：  
  - 从网络、数据库等非文件系统位置加载类。  
  - 对类字节码进行加密/解密（加载前解密，增强安全性）。  
  - 实现类的热部署（动态替换已加载的类）。  
- **特点**：父加载器通常是应用程序类加载器（可通过构造方法指定）。


### 类加载器的核心机制：双亲委派模型
上述类加载器通过“双亲委派模型”工作：当一个类加载器需要加载某个类时，它会先委托给父加载器尝试加载；如果父加载器无法加载（找不到该类），才会由自己尝试加载。  

**作用**：  
1. 避免类的重复加载（父加载器已加载的类，子加载器无需重复加载）。  
2. 保证Java核心类的安全性（防止恶意代码篡改核心类，如自定义`java.lang.Object`类无法被加载）。


总结来说，Java的类加载器通过层级划分和双亲委派机制，既保证了核心类的安全加载，又支持了用户自定义的灵活扩展。