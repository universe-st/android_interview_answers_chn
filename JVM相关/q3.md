# 介绍一下类加载器的双亲委托模型。

类加载器的**双亲委托模型（Parent Delegation Model）** 是Java中类加载机制的核心原则，它定义了类加载器之间的协作方式，旨在保证类加载的安全性和一致性。


### 核心定义  
当一个类加载器需要加载某个类时，它不会首先自己尝试加载，而是**优先将加载请求委托给其父加载器**。只有当父加载器无法完成加载（即找不到该类）时，子加载器才会尝试自己加载。  


### 工作流程  
1. **委托阶段**：当类加载器（如应用程序类加载器）收到类加载请求时，首先将请求向上委托给其父加载器（如扩展类加载器）。  
2. **逐级向上**：父加载器会重复这一过程，继续将请求委托给它的父加载器（如扩展类加载器委托给启动类加载器），直到请求到达最顶层的启动类加载器。  
3. **尝试加载**：最顶层的类加载器（启动类加载器）会尝试加载该类。如果能加载（如核心类库中的类），则直接返回加载结果；如果不能加载，就将请求向下传递给子加载器。  
4. **逐级向下**：子加载器收到父加载器无法加载的反馈后，会尝试自己加载。如果所有层级的类加载器都无法加载，则抛出`ClassNotFoundException`。  


### 举例说明  
假设要加载一个自定义类`com.example.MyClass`：  
- 应用程序类加载器（子）先委托给扩展类加载器（父）；  
- 扩展类加载器再委托给启动类加载器（顶层）；  
- 启动类加载器无法加载（`com.example`包不属于核心类库），将请求返回给扩展类加载器；  
- 扩展类加载器也无法加载（`com.example`不在扩展目录），将请求返回给应用程序类加载器；  
- 应用程序类加载器在classpath中找到`MyClass.class`，最终完成加载。  


### 核心优势  
1. **避免类的重复加载**：  
   父加载器已加载的类，子加载器无需重复加载，保证同一个类在JVM中只有一份字节码，避免内存浪费和类实例冲突。  

2. **保证Java核心类的安全性**：  
   防止恶意代码篡改核心类。例如，若用户自定义一个`java.lang.Object`类，由于启动类加载器已经加载了核心库中的`java.lang.Object`，根据双亲委托模型，自定义的`Object`类会被忽略，从而保护核心类库的完整性。  


### 实现原理  
双亲委托模型的逻辑主要在`ClassLoader`类的`loadClass()`方法中实现，伪代码逻辑如下：  
```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查该类是否已被当前加载器加载过
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    // 2. 委托父加载器加载
                    c = parent.loadClass(name, false);
                } else {
                    // 3. 父加载器为null（启动类加载器），尝试用启动类加载器加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 父加载器无法加载
            }
            
            if (c == null) {
                // 4. 父加载器加载失败，当前加载器自己尝试加载
                c = findClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```


### 总结  
双亲委托模型通过“先委托父加载器，后自己尝试”的机制，既保证了类加载的唯一性，又保护了Java核心类库的安全，是Java类加载体系的基础。不过，在某些场景下（如SPI服务加载），可能会通过线程上下文类加载器打破这一模型，但这属于特殊扩展，不影响模型的核心地位。