# 描述JVM类加载过程

JVM的类加载过程是将.class文件中的二进制数据加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被JVM直接使用的Java类型的过程。整个过程主要分为**加载、验证、准备、解析、初始化**五个阶段，这五个阶段按顺序执行（解析阶段可能在初始化阶段之后开始，以支持动态绑定）。


### 1. 加载（Loading）
加载是类加载过程的第一个阶段，JVM需要完成三件事：  
- **获取字节流**：通过类的全限定名（如`java.lang.String`），获取定义该类的二进制字节流（.class文件）。字节流的来源可以是本地文件、网络传输、动态生成（如动态代理）、数据库读取等。  
- **转换存储结构**：将字节流所代表的静态存储结构（.class文件格式）转换为方法区的运行时数据结构（JVM内部对类信息的存储格式）。  
- **生成Class对象**：在内存中生成一个代表该类的`java.lang.Class`对象（通常存放在堆中），作为方法区中该类所有数据的访问入口。  


### 2. 验证（Verification）
验证是为了确保.class文件的字节流中包含的信息符合当前JVM的规范，**防止恶意或无效的字节流危害虚拟机安全**。验证过程主要包括四个方面：  
- **文件格式验证**：验证字节流是否符合.class文件格式规范（如魔数是否为`0xCAFEBABE`、版本号是否兼容当前JVM等）。  
- **元数据验证**：验证类的元数据信息是否合法（如是否有父类、是否继承了final类、字段/方法是否与父类冲突等）。  
- **字节码验证**：验证方法体的字节码指令是否合法（如是否存在非法跳转、操作数类型是否匹配等），确保代码逻辑安全可执行。  
- **符号引用验证**：验证常量池中的符号引用（如类名、方法名）是否合法（如是否引用了不存在的类、方法参数类型是否匹配等）。  


### 3. 准备（Preparation）
准备阶段为类变量（被`static`修饰的变量）**分配内存并设置初始值**，内存分配发生在方法区（JDK 8及以后为元空间）。  
- **初始值**：这里的初始值是“默认零值”（如`int`为0，`boolean`为`false`，引用类型为`null`），而非代码中显式赋值的值。  
- **特殊情况**：如果类变量被`final`修饰（如`public static final int VALUE = 100`），则在准备阶段会直接赋值为100（编译时已确定值，存储在常量池）。  
- **注意**：实例变量（非static）的内存分配和初始化在对象实例化时发生在堆中，与准备阶段无关。  


### 4. 解析（Resolution）
解析阶段将常量池中的**符号引用**转换为**直接引用**。  
- **符号引用**：用一组符号（如类名、方法名、字段名）描述目标的引用（不依赖内存布局，编译期确定）。  
- **直接引用**：直接指向目标的内存地址（如指针、偏移量），依赖JVM的内存布局（运行期确定）。  
- **解析对象**：包括类或接口、字段、类方法、接口方法、方法类型等。例如，将“`java.lang.Object`”这个符号引用转换为其在方法区中的内存地址。  


### 5. 初始化（Initialization）
初始化是类加载过程的最后一步，**真正执行类中定义的Java代码**（静态变量赋值和静态代码块）。其核心是执行类构造器`<clinit>()`方法：  
- `<clinit>()`方法由编译器自动生成，整合了类中所有**静态变量的赋值语句**和**静态代码块（static{}）**，执行顺序与代码在源文件中的出现顺序一致。  
- JVM保证：子类的`<clinit>()`执行前，父类的`<clinit>()`已执行完毕（因此父类静态代码块优先于子类执行）。  
- 触发条件：只有当类被“主动使用”时才会触发初始化，例如：创建类的实例、调用类的静态方法、访问类的静态变量（非final）、反射调用类、初始化子类时（父类未初始化则先初始化父类）等。  


### 总结
类加载的五个阶段（加载→验证→准备→解析→初始化）是JVM将.class文件转换为可执行类型的核心过程，其中验证、准备、解析可统称为“连接”阶段。类加载完成后，类会进入“使用”阶段（对象实例化、方法调用等），最终在生命周期结束后被“卸载”（从方法区移除）。