# Android在转屏后恢复View状态，用什么方案？

Android 转屏时会触发 **Activity 重建**（默认行为），导致 View 状态（如输入框文本、复选框选中状态、滚动位置等）丢失。恢复 View 状态的核心是：**在 Activity 销毁前保存状态，重建后恢复状态**。以下是 5 种常用方案，按「易用性+推荐度」排序：


## 一、系统默认恢复（无需手动编码，优先使用）
### 原理
Android 系统自带状态保存机制：当 Activity 即将销毁时，会自动调用所有 **带 id 的 View** 的 `onSaveInstanceState()` 方法，将 View 的「基础状态」（如 `EditText` 文本、`CheckBox` 选中状态、`RadioButton` 选中项）保存到 `Bundle`；Activity 重建后，系统会通过 `onRestoreInstanceState()` 自动恢复这些状态。

### 用法
只需满足 2 个条件：
1. View 必须设置 **唯一的 `android:id`**（系统通过 id 识别 View，无 id 则不保存）；
2. 不主动禁用状态保存（如 `setSaveEnabled(false)`）。

### 示例
```xml
<!-- 布局文件：给需要恢复状态的 View 设 id -->
<EditText
    android:id="@+id/et_input"  <!-- 关键：必须有 id -->
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/>

<CheckBox
    android:id="@+id/cb_agree"  <!-- 关键：必须有 id -->
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="同意协议"/>
```

### 适用场景
- 原生 View（`EditText`、`CheckBox`、`RadioButton`、`Switch` 等）的基础状态恢复；
- 无需自定义状态（如仅需保存默认支持的状态）。

### 注意
- 系统仅保存「View 自带的基础状态」（如 `EditText` 文本、`CheckBox` 选中态），不保存自定义数据（如自定义 View 的计数器值）；
- `TextView` 需设置 `android:freezesText="true"` 才能保存文本（`EditText` 默认开启）。


## 二、自定义 View 状态保存（适用于自定义 View）
### 原理
如果是自定义 View（如带计数器的按钮、自定义进度条），系统无法识别其「自定义状态」（如计数器数值），需手动重写 `onSaveInstanceState()` 和 `onRestoreInstanceState()`，将自定义状态存入 `Bundle`。

### 用法
1. 重写 `onSaveInstanceState()`：保存自定义状态到 `Parcelable` 对象（需实现 `Parcelable` 接口）；
2. 重写 `onRestoreInstanceState()`：从 `Parcelable` 中恢复状态；
3. 确保自定义 View 设置了 `android:id`（否则系统不会调用上述方法）。

### 示例（自定义计数器 View）
```kotlin
class CounterView @JvmOverloads constructor(
    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    private var count = 0  // 自定义状态：计数器值

    // 保存状态：返回封装了自定义状态的 Parcelable
    override fun onSaveInstanceState(): Parcelable? {
        // 先保存父类的状态（必须调用，避免丢失基础状态）
        val superState = super.onSaveInstanceState()
        // 封装自定义状态
        return SavedState(superState, count)
    }

    // 恢复状态：从 Parcelable 中读取自定义状态
    override fun onRestoreInstanceState(state: Parcelable?) {
        if (state !is SavedState) {
            super.onRestoreInstanceState(state)
            return
        }
        // 先恢复父类状态
        super.onRestoreInstanceState(state.superState)
        // 恢复自定义状态
        count = state.count
        invalidate()  // 刷新 View 显示
    }

    // 封装自定义状态的 Parcelable 类
    private class SavedState : BaseSavedState {
        val count: Int

        constructor(superState: Parcelable?, count: Int) : super(superState) {
            this.count = count
        }

        // 从 Parcel 中读取数据（反序列化）
        constructor(parcel: Parcel) : super(parcel) {
            count = parcel.readInt()
        }

        // 序列化（必须实现，否则报错）
        companion object CREATOR : Parcelable.Creator<SavedState> {
            override fun createFromParcel(parcel: Parcel): SavedState {
                return SavedState(parcel)
            }

            override fun newArray(size: Int): Array<SavedState?> {
                return arrayOfNulls(size)
            }
        }
    }

    // 点击增加计数（测试用）
    fun increment() {
        count++
        invalidate()
    }

    // 绘制计数（测试用）
    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        canvas.drawText("Count: $count", 50f, 50f, Paint().apply { textSize = 30f })
    }
}
```

### 适用场景
- 自定义 View 的「自定义状态」恢复（如计数器值、进度值、自定义选中态等）。


## 三、Activity/Fragment 手动保存（适用于页面级数据）
### 原理
当需要保存「非 View 自身状态」（如列表滚动位置、当前选中的 Tab 索引、自定义变量）时，可通过 Activity/Fragment 的 `onSaveInstanceState()` 方法，将数据存入 `Bundle`，重建后从 `Bundle` 中读取恢复。

### 用法（Activity 示例）
1. 重写 `onSaveInstanceState(outState: Bundle)`：将需要保存的数据存入 `outState`；
2. 在 `onCreate(savedInstanceState: Bundle?)` 或 `onRestoreInstanceState(savedInstanceState: Bundle)` 中恢复数据。

### 示例（保存列表滚动位置+自定义变量）
```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var recyclerView: RecyclerView
    private lateinit var adapter: MyAdapter
    private var currentTabIndex = 0  // 自定义变量：当前选中的 Tab 索引
    private var recyclerState: Parcelable? = null  // 列表滚动状态

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 初始化 View
        recyclerView = findViewById(R.id.recycler_view)
        adapter = MyAdapter()
        recyclerView.adapter = adapter
        recyclerView.layoutManager = LinearLayoutManager(this)

        // 恢复状态（判断 savedInstanceState 是否不为空，避免首次创建时空指针）
        if (savedInstanceState != null) {
            currentTabIndex = savedInstanceState.getInt("tab_index", 0)
            recyclerState = savedInstanceState.getParcelable("recycler_state")
            // 恢复列表滚动位置（需在 adapter 数据设置后调用）
            recyclerState?.let { recyclerView.layoutManager?.onRestoreInstanceState(it) }
        }
    }

    // 保存状态：Activity 销毁前调用
    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // 保存自定义变量
        outState.putInt("tab_index", currentTabIndex)
        // 保存列表滚动状态（LayoutManager 自带状态保存）
        recyclerState = recyclerView.layoutManager?.onSaveInstanceState()
        outState.putParcelable("recycler_state", recyclerState)
    }

    // 可选：onRestoreInstanceState 仅在有保存状态时调用，无需判空
    override fun onRestoreInstanceState(savedInstanceState: Bundle) {
        super.onRestoreInstanceState(savedInstanceState)
        currentTabIndex = savedInstanceState.getInt("tab_index")
        recyclerState = savedInstanceState.getParcelable("recycler_state")
    }
}
```

### 适用场景
- 保存页面级数据（如 Tab 索引、列表滚动位置、临时变量）；
- 原生 View 无法自动保存的状态（如 `RecyclerView` 滚动位置）。

### 注意
- `Bundle` 仅支持「可序列化数据」（`int`、`String`、`Parcelable`、`Serializable` 等），不支持复杂对象（如网络请求回调、数据库连接）；
- 避免存入过大数据（如 Bitmap），可能导致内存溢出或恢复缓慢。


## 四、ViewModel（Jetpack 推荐方案，适用于复杂场景）
### 原理
`ViewModel` 是 Jetpack 组件，其生命周期**独立于 Activity 配置变更**（转屏、分屏等）：Activity 重建时，`ViewModel` 实例不会销毁，而是被新的 Activity 实例复用，因此可用于存放需要跨配置变更保留的数据。

### 用法
1. 依赖 Jetpack ViewModel（需在 `build.gradle` 中添加依赖）；
2. 自定义 `ViewModel` 类，存放需要保留的数据；
3. 在 Activity/Fragment 中通过 `ViewModelProvider` 获取 `ViewModel` 实例，直接读取/修改数据。

### 示例
#### 1. 添加依赖（Module 级 build.gradle）
```gradle
dependencies {
    // ViewModel（AndroidX）
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.2"
    // Fragment 配合使用（可选）
    implementation "androidx.lifecycle:lifecycle-viewmodel-savedstate:2.6.2"
}
```

#### 2. 自定义 ViewModel
```kotlin
// 存放跨配置变更需要保留的数据
class MainViewModel : ViewModel() {
    // 列表数据（无需序列化，直接持有）
    val listData = MutableLiveData<List<String>>()
    // 当前选中的 Tab 索引
    var currentTabIndex = 0
    // 列表滚动状态
    var recyclerState: Parcelable? = null
}
```

#### 3. 在 Activity 中使用
```kotlin
class MainActivity : AppCompatActivity() {
    private lateinit var viewModel: MainViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 获取 ViewModel 实例（重建时会复用旧实例）
        viewModel = ViewModelProvider(this)[MainViewModel::class.java]

        // 初始化列表
        val recyclerView = findViewById<RecyclerView>(R.id.recycler_view)
        val adapter = MyAdapter()
        recyclerView.adapter = adapter
        recyclerView.layoutManager = LinearLayoutManager(this)

        // 观察列表数据（ViewModel 中的数据不会因转屏丢失）
        viewModel.listData.observe(this) { data ->
            adapter.setData(data)
            // 恢复列表滚动位置
            viewModel.recyclerState?.let {
                recyclerView.layoutManager?.onRestoreInstanceState(it)
            }
        }

        // 模拟加载数据（仅首次创建时加载，转屏后不复用）
        if (viewModel.listData.value.isNullOrEmpty()) {
            loadData()
        }
    }

    // 保存列表滚动状态（如 onPause 时）
    override fun onPause() {
        super.onPause()
        val recyclerView = findViewById<RecyclerView>(R.id.recycler_view)
        viewModel.recyclerState = recyclerView.layoutManager?.onSaveInstanceState()
    }

    // 模拟网络请求加载数据
    private fun loadData() {
        val data = listOf("Item 1", "Item 2", "Item 3", ...)
        viewModel.listData.value = data
    }
}
```

### 适用场景
- 复杂数据（如列表数据、网络请求结果、大数据集合）；
- 需跨配置变更长期持有对象（如数据库实例、网络客户端）；
- 现代 Android 开发（推荐优先使用，替代 `onSaveInstanceState` 保存复杂数据）。

### 注意
- `ViewModel` 不能持有 `Context`（会导致内存泄漏），如需使用 `Context`，可使用 `AndroidViewModel`（继承自 `ViewModel`，持有 `Application` 上下文）；
- 若需持久化数据（如退出 App 后仍保留），需配合 `Room`（数据库）或 `DataStore`，`ViewModel` 仅保留内存数据。


## 五、其他方案（不推荐，仅特殊场景使用）
### 1. 禁止转屏（回避问题）
在 `AndroidManifest.xml` 中给 Activity 设置 `screenOrientation`，禁止转屏：
```xml
<activity
    android:name=".MainActivity"
    android:screenOrientation="portrait">  <!-- 固定竖屏 -->
</activity>
```
- 适用场景：特殊页面（如游戏、视频播放器），无需适配横屏；
- 缺点：不灵活，无法适配多屏幕方向，不符合 Android 设计规范。

### 2. 过时方法：`onRetainNonConfigurationInstance()`
早期 Android 提供的方法，用于保存非配置变更数据，现已被 `ViewModel` 替代：
```kotlin
// 过时！不推荐使用
override fun onRetainNonConfigurationInstance(): Any? {
    return listData  // 保存数据
}

// 恢复数据
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val data = lastNonConfigurationInstance  // 获取保存的数据
}
```
- 缺点：API 过时，无法配合 Jetpack 生态，易导致内存泄漏。


## 常见问题与注意事项
1. **`RecyclerView` 滚动位置恢复**：系统不会自动保存，需手动保存 `LayoutManager` 的状态（如方案三、四示例）；
2. **`EditText` 文本恢复**：必须设置 `android:id`，且不能调用 `setText("")`（会覆盖恢复的文本）；
3. **`Bundle` 数据大小限制**：`onSaveInstanceState` 保存的数据会存入系统进程，建议不超过 100KB，过大可能导致恢复失败；
4. **内存泄漏风险**：`ViewModel` 中避免持有 `Activity/Fragment` 上下文，如需使用上下文，用 `AndroidViewModel`；
5. **持久化 vs 内存保存**：`onSaveInstanceState` 和 `ViewModel` 仅保存内存数据，退出 App 后丢失；需持久化则用 `Room`/`DataStore`。


## 方案选择建议
| 场景 | 推荐方案 |
|------|----------|
| 原生 View 基础状态（输入框、复选框） | 系统默认恢复（设 id） |
| 自定义 View 自定义状态 | 自定义 View 状态保存（重写 onSave/onRestore） |
| 页面级简单数据（Tab 索引、小变量） | Activity/Fragment 手动保存（onSaveInstanceState） |
| 复杂数据、跨配置变更持有对象 | ViewModel（Jetpack） |
| 无需适配横屏的特殊页面 | 禁止转屏 |

**核心推荐**：优先使用「系统默认恢复」+「ViewModel」，覆盖 90% 以上场景，兼顾易用性和性能。